pulse_read_version <- function(path) {
  path %>%
    readr::read_lines(n_max = 50) %>%
    stringr::str_to_lower() %>%
    stringr::str_subset("pulse version") %>%
    stringr::str_replace_all("[^0-9.]", "") %>%
    as.numeric()
}

pulse_read_freq <- function(path) {
  path %>%
    readr::read_lines(n_max = 50) %>%
    stringr::str_to_lower() %>%
    stringr::str_subset("rate_hz") %>%
    stringr::str_replace_all("[^0-9]", "") %>%
    as.numeric()
}

pulse_read_channels <- function(path) {
  path %>%
    readr::read_lines(n_max = 50) %>%
    stringr::str_to_lower() %>%
    stringr::str_subset(pattern = "^s[:digit:]{1,2},") %>%
    stringr::str_split(",") %>%
    purrr::map_chr(2)
}

pulse_read_skip <- function(path) {
  path %>%
    readr::read_lines(n_max = 50) %>%
    stringr::str_which("----------------") %>%
    max()
}

pulse_read_data <- function(path, skip, cols, multi = TRUE) {
  if (multi) {
    lines <- path %>%
      readr::read_lines(skip = skip + 1) %>%
      stringr::str_split(",")

    # check that timestamps have the correct length
    valid1 <- purrr::map_lgl(lines, ~nchar(.x[1]) == 23)

    # check that lines have the correct number of elements
    valid2 <- purrr::map_lgl(lines, ~length(.x) == if (multi) 11 else 2)

    # only keep lines that pass both tests
    lines <- lines[valid1 & valid2]

    # rebuild data
    data <- do.call(rbind, lines) %>%
      tibble::as_tibble(.name_repair = "minimal")
    colnames(data) <- c("time", cols)

    data <- data %>%
      dplyr::mutate(time = as.POSIXct(time)) %>%
      dplyr::mutate(dplyr::across(-time, ~as.numeric(.x)))

    return(data)
  } else {
    stop("currently only 'multi = TRUE' is supported")
  }
}

add_line <- function(msg1, msg2) {
  stringr::str_c(msg1, "\n - ", msg2)
}

#' before pulse_read
#'
#' @description
#' before pulse_read
#'
#' @param paths File paths to CSV files produced by a PULSE system during a single experiment.
#'
#' @return
#' _
#'
#' @export
#'
#' @examples
#' _
pulse_read_checks <- function(paths) {
  ok  <- FALSE
  out <- list()

  # check that all 'paths' exist
  if (!all(file.exists(paths))) {
    msg <- "\n  --> [x] all 'paths' must exist"
  } else {

    # check that all 'paths' are files (not folders)
    if (!all(!file.info(paths)$isdir)) {
      msg <- "\n  --> [x] 'paths' must point to files (not folders)"
    } else {

      # check that all paths point to PULSE files
      all_pulse <- paths %>%
        purrr::map_lgl(is.pulse) %>%
        all()

      if (!all_pulse) {
        msg <- "\n  --> [x] 'paths' must only include PULSE files"
      } else {

        # check that all paths point to files from the PULSE multi-channel system
        # PULSE one-channel files are not yet supported
        all_pulse_multi <- paths %>%
          purrr::map_lgl(is.pulse.multi) %>%
          all()

        if (!all_pulse_multi) {
          msg <- "\n  --> [x] 'paths' must only include PULSE files generated by a PULSE multi-channel system\n  --> [i] PULSE one-channel files are not yet supported"
        } else {

          # check that all PULSE files share the same header
          #   (i.e., are from the same experiment)
          # this is done by ensuring that the names of the channels are
          #   the same in all files, as well as 'Rate_Hz' and the number of
          #   lines in the header
          cols <- paths %>%
            purrr::map(pulse_read_channels)
          COLS <- stringr::str_c("c", 1:length(cols[[1]]))
          cols <- do.call(rbind, cols)
          colnames(cols) <- COLS
          cols <- cols %>%
            tibble::as_tibble() %>%
            dplyr::distinct()
          freq <- purrr::map_dbl(paths, pulse_read_freq) %>% unique()
          skip <- purrr::map_dbl(paths, pulse_read_skip) %>% unique()
          vrsn <- purrr::map_dbl(paths, pulse_read_version) %>% unique()

          lgl_cols <- nrow(cols)   != 1
          lgl_freq <- length(freq) != 1
          lgl_skip <- length(skip) != 1
          lgl_vrsn <- length(vrsn) != 1

          if (lgl_cols | lgl_freq | lgl_skip | lgl_vrsn) {
            msg <- "\n  --> [x] found differences in the headers across the PULSE CSV files\n  --> [i] inconsistencies detected:"
            if (lgl_cols) msg <- stringr::str_c(msg, "\n           - names of the channels (even unused channels must match)")
            if (lgl_freq) msg <- stringr::str_c(msg, "\n           - sampling rate 'Rate_Hz' ")
            if (lgl_skip) msg <- stringr::str_c(msg, "\n           - number of lines of the headers")
            if (lgl_vrsn) msg <- stringr::str_c(msg, "\n           - PULSE system versions")
            msg <- stringr::str_c(msg, "\n  --> [?] are you sure that all files originated from a single experiment?\n  --> [i] if yes, edit the headers manually to fix all inconsistencies and re-run the code")
          } else {

            # check that all channels have unique names
            cols <- as.character(cols)

            if (length(cols) != length(unique(cols))) {
              msg <- "\n  --> [x] the names of all channels must be unique (including unsused channels)"
            } else {

              # all checks passed
              ok <- TRUE
              out <- list(
                cols = cols,
                freq = freq,
                skip = skip,
                vrsn = vrsn
              )
              msg <- "  --> [i] 'paths' points to valid PULSE files"
            }
          }

        }
      }
    }
  }
  list(ok = ok, msg = msg, out = out)
}

#' Read data from all PULSE files in the target folder (`STEP 1`)
#'
#' @description
#' * **`-->>` step 1 -- [`pulse_read()`] `<<--`**
#' * `step 2` -- [`pulse_split()`]
#' * `step 3` -- [`pulse_optimize()`]
#' * `step 4` -- [`pulse_heart()`]
#'
#' Importing data from PULSE `'.csv'` files is the first step of the analysis of PULSE data.
#'
#' `pulse_read()` checks that the paths provided by the user conform to certain expectations and then reads the data from all files and merges into a single tibble. Only data from the same experiment should be read at the same time (i.e., with the same channel names, collected with the same sampling frequency, and produced using a PULSE multi-channel system running the same firmware version throughout the experiment). To put it differently, one call to `pulse_read()` can only read files where the header is absolutely invariant, and only the data portion of the files differs. The output of `pulse_read()` can be directly passed on to `pulse_split()`.
#'
#' @param paths File paths to CSV files produced by a PULSE system during a single experiment.
#' @param with_progress One of `TRUE`, `FALSE` or `NULL` (default) to choose whether to show progress bars or not (based on the `progressr` package). `TRUE` prints a `cli`-style progress bar; `FALSE` disables progress bars altogether; if set to `NULL`, the behavior is controlled by the user from outside this function (by setting the desired `handlers()`; in addition, setting `handlers(global = TRUE)` ensures the same behavior is used across the entire session).
#' @param msg A logical to decide if non-crucial messages (but not errors) are shown (defaults to `TRUE`; mainly for use from within the wrapper function `PULSE()`, where it is set to `FALSE` to avoid the repetition of identical messages)
#'
#' @seealso
#'  * check [progressr::handlers()] to customize the reporting of progress
#'  * [pulse_split()], [pulse_optimize()] and [pulse_heart()] are the other functions needed for the complete PULSE processing workflow
#'  * [PULSE()] is a wrapper function that executes all the steps needed to process PULSE data at once
#'
#' @return
#' A list with two elements:
#' * `$data`, A tibble with 11 columns (time + 10 channels) containing all data from all PULSE files
#' * `$freq`, A numeric scalar with the sampling frequency used (in Hz)
#'
#' @export
#'
#' @examples
#' # Begin prepare data ----
#' paths <- pulse_example("RAW_original_")
#' # End prepare data ----
#'
#' pulse_read(paths, with_progress = TRUE)
pulse_read <- function(paths, with_progress = NULL, msg = TRUE) {
  checks <- pulse_read_checks(paths)
  if (!checks$ok) {
    stop(checks$msg)
  } else {
    if (msg) message(checks$msg)
  }

  cols <- checks$out$cols
  freq <- checks$out$freq
  skip <- checks$out$skip
  vrsn <- checks$out$vrsn

  # set progress reporting strategy
  if (!is.null(with_progress)) {
    if (with_progress) {
      old_handlers <- progressr::handlers("cli")
    } else {
      old_handlers <- progressr::handlers("void")
    }
    on.exit(if (is.null(old_handlers)) progressr::handlers("void") else progressr::handlers(old_handlers), add = TRUE)
  }

  # read PULSE files
  bar <- progressr::progressor(along = paths)
  pulse_data <- list()
  for (i in seq_along(paths)) {
    pulse_data[[i]] <- pulse_read_data(paths[i], skip = skip, cols = cols, multi = TRUE)
    bar(message = "reading PULSE files |")
  }

  # merge
  pulse_data <- pulse_data %>%
    dplyr::bind_rows() %>%
    dplyr::arrange(time)

  # return
  pulse_data <- list(data = pulse_data, freq = freq)
  return(pulse_data)
}
