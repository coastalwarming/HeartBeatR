% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pulse_optimize.R
\name{pulse_smooth}
\alias{pulse_smooth}
\title{Smooth PULSE data}
\usage{
pulse_smooth(split_window, bandwidth = 0.2)
}
\arguments{
\item{split_window}{One element of \code{pulse_data_split} (which is the output from \code{pulse_split()}).}

\item{bandwidth}{A numeric value expressing the bandwidth. If equal to \code{0} (zero) no smoothing is applied. Ideally kept low (defaults to \code{0.2}) so that only very high frequency noise is removed, but can be pushed up all the way to \code{1} or above (especially when the heartbeat rate is expected to be slow, as is typical of oysters, but double check the resulting data). Type \code{?ksmooth} for additional info.}
}
\value{
The same PULSE tibble supplied in \code{split_window}, with the standard 2 or more columns (time + one or more channels), but now with data for all channels smoothed.
}
\description{
The performance of the algorithm employed in the downstream function \code{pulse_heart()} for the detection of heart beat wave crests depends significantly on the data not being too noisy. \code{pulse_smooth()} reshapes the data non-destructively and improves the likelihood of \code{pulse_heart()} successfully estimating the inherent heartbeat rates.
\itemize{
\item \code{SMOOTHING} isn't crucial, but should be experimented with when \code{pulse_heart()} produces too many heartbeat rate estimates that are clearly incorrect. In such situations, \code{pulse_smooth()} applies a smoothing filter (normal Kernel Regression Smoother) to the data to smooth out high-frequency noise and render a more sinusoidal wave, which is easier to handle. Users should exercise caution when setting \code{bandwidth} and generally opt for lower values, as there's a threshold to bandwidth values above which the resulting smoothed pulse data becomes completely unrelated to the original data, and the subsequent heartbeat rates computed with \code{pulse_heart()} will be totally wrong. Always double-check the data after applying a stronger smoothing. Note that if applied with the default \code{bandwidth}, smoothing incurs no penalty and hardly changes the data - so it isn't worth going out of the way to not apply smoothing.
}
}
\examples{
## Begin prepare data ----
pulse_data_sub <- pulse_data
pulse_data_sub$data <- pulse_data_sub$data[,1:5]
pulse_data_split <- pulse_split(
   pulse_data_sub,
   window_width_secs = 30,
   window_shift_secs = 60,
   min_data_points = 0.8,
   with_progress = TRUE)
## End prepare data ----

# Smooth data slightly ('bandwidth' = 2)
pulse_smooth(pulse_data_split$data[[1]], 0.2)
}
\seealso{
\itemize{
\item \code{\link[=ksmooth]{ksmooth()}} is used for the kernel smoothing of PULSE data
\item \code{\link[=pulse_optimize]{pulse_optimize()}} is a wrapper function that executes \code{\link[=pulse_interpolate]{pulse_interpolate()}} and \code{pulse_smooth} sequentially
\item \code{\link[=pulse_read]{pulse_read()}}, \code{\link[=pulse_split]{pulse_split()}}, \code{\link[=pulse_heart]{pulse_heart()}} and \code{\link[=pulse_doublecheck]{pulse_doublecheck()}} are the other functions needed for the complete PULSE processing workflow
\item \code{\link[=PULSE]{PULSE()}} is a wrapper function that executes all the steps needed to process PULSE data at once
}
}
